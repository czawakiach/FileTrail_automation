import tkinter as tk
from tkinter import ttk, filedialog, messagebox
import pandas as pd
import numpy as np
from fuzzywuzzy import fuzz
import re
import os
from datetime import datetime
import threading


class FileTrailComparator:
    def __init__(self, root):
        self.root = root
        self.root.title("FileTrail Data Comparison Tool")
        self.root.geometry("800x600")
        
        # File paths
        self.file_paths = {
            'filetrail': None,
            'exploration_archives': None,
            'open_works': None,
            'lines_3d': None
        }
        
        # Data storage
        self.data = {}
        self.results = {}
        
        self.create_widgets()
        
    def create_widgets(self):
        # Main frame
        main_frame = ttk.Frame(self.root, padding="10")
        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # Title
        title_label = ttk.Label(main_frame, text="FileTrail Data Comparison Tool", 
                               font=("Arial", 16, "bold"))
        title_label.grid(row=0, column=0, columnspan=3, pady=(0, 20))
        
        # File selection section
        file_frame = ttk.LabelFrame(main_frame, text="File Selection", padding="10")
        file_frame.grid(row=1, column=0, columnspan=3, sticky=(tk.W, tk.E), pady=(0, 10))
        
        # FileTrail (required)
        ttk.Label(file_frame, text="FileTrail Search Result (Required):").grid(row=0, column=0, sticky=tk.W, pady=2)
        self.filetrail_var = tk.StringVar()
        ttk.Entry(file_frame, textvariable=self.filetrail_var, width=50).grid(row=0, column=1, padx=5)
        ttk.Button(file_frame, text="Browse", 
                  command=lambda: self.browse_file('filetrail')).grid(row=0, column=2)
        
        # Exploration Archives (optional)
        ttk.Label(file_frame, text="Exploration Archives (Optional):").grid(row=1, column=0, sticky=tk.W, pady=2)
        self.exploration_var = tk.StringVar()
        ttk.Entry(file_frame, textvariable=self.exploration_var, width=50).grid(row=1, column=1, padx=5)
        ttk.Button(file_frame, text="Browse", 
                  command=lambda: self.browse_file('exploration_archives')).grid(row=1, column=2)
        
        # Open Works (optional)
        ttk.Label(file_frame, text="Open Works (Optional):").grid(row=2, column=0, sticky=tk.W, pady=2)
        self.open_works_var = tk.StringVar()
        ttk.Entry(file_frame, textvariable=self.open_works_var, width=50).grid(row=2, column=1, padx=5)
        ttk.Button(file_frame, text="Browse", 
                  command=lambda: self.browse_file('open_works')).grid(row=2, column=2)
        
        # 3D Lines (optional)
        ttk.Label(file_frame, text="3D Lines Project (Optional):").grid(row=3, column=0, sticky=tk.W, pady=2)
        self.lines_3d_var = tk.StringVar()
        ttk.Entry(file_frame, textvariable=self.lines_3d_var, width=50).grid(row=3, column=1, padx=5)
        ttk.Button(file_frame, text="Browse", 
                  command=lambda: self.browse_file('lines_3d')).grid(row=3, column=2)
        
        # Processing section
        process_frame = ttk.LabelFrame(main_frame, text="Processing", padding="10")
        process_frame.grid(row=2, column=0, columnspan=3, sticky=(tk.W, tk.E), pady=(0, 10))
        
        # Process button
        self.process_button = ttk.Button(process_frame, text="Process Data", 
                                        command=self.process_data_threaded)
        self.process_button.grid(row=0, column=0, pady=5)
        
        # Progress bar
        self.progress_var = tk.DoubleVar()
        self.progress_bar = ttk.Progressbar(process_frame, variable=self.progress_var, 
                                           maximum=100, length=300)
        self.progress_bar.grid(row=0, column=1, padx=10, pady=5)
        
        # Status label
        self.status_var = tk.StringVar(value="Ready")
        self.status_label = ttk.Label(process_frame, textvariable=self.status_var)
        self.status_label.grid(row=0, column=2, padx=10)
        
        # Results section
        results_frame = ttk.LabelFrame(main_frame, text="Results", padding="10")
        results_frame.grid(row=3, column=0, columnspan=3, sticky=(tk.W, tk.E, tk.N, tk.S), pady=(0, 10))
        
        # Results text area
        self.results_text = tk.Text(results_frame, height=15, width=80)
        scrollbar = ttk.Scrollbar(results_frame, orient=tk.VERTICAL, command=self.results_text.yview)
        self.results_text.configure(yscrollcommand=scrollbar.set)
        self.results_text.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        scrollbar.grid(row=0, column=1, sticky=(tk.N, tk.S))
        
        # Export button
        self.export_button = ttk.Button(main_frame, text="Export to Excel", 
                                       command=self.export_to_excel, state=tk.DISABLED)
        self.export_button.grid(row=4, column=0, columnspan=3, pady=10)
        
        # Configure grid weights
        main_frame.columnconfigure(1, weight=1)
        main_frame.rowconfigure(3, weight=1)
        results_frame.columnconfigure(0, weight=1)
        results_frame.rowconfigure(0, weight=1)
        
    def browse_file(self, file_type):
        """Browse for file selection"""
        file_path = filedialog.askopenfilename(
            title=f"Select {file_type.replace('_', ' ').title()} File",
            filetypes=[("Excel files", "*.xlsx *.xls"), ("CSV files", "*.csv"), ("All files", "*.*")]
        )
        
        if file_path:
            self.file_paths[file_type] = file_path
            
            # Update the corresponding StringVar
            if file_type == 'filetrail':
                self.filetrail_var.set(file_path)
            elif file_type == 'exploration_archives':
                self.exploration_var.set(file_path)
            elif file_type == 'open_works':
                self.open_works_var.set(file_path)
            elif file_type == 'lines_3d':
                self.lines_3d_var.set(file_path)
    
    def normalize_string(self, text):
        """Normalize string for comparison"""
        if pd.isna(text) or text is None:
            return ""
        
        # Convert to string and uppercase
        normalized = str(text).upper().strip()
        
        # Remove common suffixes and prefixes
        normalized = re.sub(r'_3D$', '', normalized)
        normalized = re.sub(r'^E0*', '', normalized)  # Remove leading E and zeros
        
        # Remove special characters except alphanumeric and underscores
        normalized = re.sub(r'[^A-Z0-9_]', '', normalized)
        
        return normalized
    
    def find_matches(self, line_id, comparison_list, match_threshold=80):
        """Find matches for a line_id in comparison list"""
        if not line_id or pd.isna(line_id):
            return []
        
        matches = []
        normalized_line_id = self.normalize_string(line_id)
        
        for item in comparison_list:
            if pd.isna(item) or not item:
                continue
                
            item_str = str(item)
            normalized_item = self.normalize_string(item_str)
            
            # Exact match (after normalization)
            if normalized_line_id == normalized_item:
                matches.append({
                    'value': item_str,
                    'match_type': 'exact',
                    'score': 100
                })
                continue
            
            # Substring match
            if (normalized_line_id in normalized_item or 
                normalized_item in normalized_line_id):
                matches.append({
                    'value': item_str,
                    'match_type': 'substring',
                    'score': 90
                })
                continue
            
            # Fuzzy match
            score = fuzz.ratio(normalized_line_id, normalized_item)
            if score >= match_threshold:
                matches.append({
                    'value': item_str,
                    'match_type': 'fuzzy',
                    'score': score
                })
        
        # Sort by score (descending)
        matches.sort(key=lambda x: x['score'], reverse=True)
        return matches
    
    def load_data(self, file_path):
        """Load data from CSV or Excel file"""
        if not file_path or not os.path.exists(file_path):
            return None
        
        try:
            if file_path.endswith('.csv'):
                return pd.read_csv(file_path)
            else:
                return pd.read_excel(file_path)
        except Exception as e:
            messagebox.showerror("Error", f"Failed to load file {file_path}: {str(e)}")
            return None
    
    def process_data_threaded(self):
        """Run data processing in a separate thread"""
        self.process_button.config(state=tk.DISABLED)
        self.export_button.config(state=tk.DISABLED)
        
        thread = threading.Thread(target=self.process_data)
        thread.daemon = True
        thread.start()
    
    def process_data(self):
        """Main data processing function"""
        try:
            # Clear previous results
            self.results_text.delete(1.0, tk.END)
            self.results = {}
            
            # Load FileTrail data (required)
            self.status_var.set("Loading FileTrail data...")
            self.progress_var.set(10)
            
            if not self.file_paths['filetrail']:
                messagebox.showerror("Error", "FileTrail file is required!")
                return
            
            filetrail_data = self.load_data(self.file_paths['filetrail'])
            if filetrail_data is None:
                return
            
            # Check for required columns
            if 'HOME_LOCATION' not in filetrail_data.columns:
                messagebox.showerror("Error", "HOME_LOCATION column not found in FileTrail file!")
                return
            
            if 'LINE_ID' not in filetrail_data.columns:
                messagebox.showerror("Error", "LINE_ID column not found in FileTrail file!")
                return
            
            # Filter by HOME_LOCATION
            self.status_var.set("Filtering by HOME_LOCATION...")
            self.progress_var.set(20)
            
            filtered_filetrail = filetrail_data[
                filetrail_data['HOME_LOCATION'].str.contains('PT_US_HOU_WCK', na=False, case=False)
            ].copy()
            
            total_filetrail = len(filetrail_data)
            filtered_count = len(filtered_filetrail)
            
            self.results_text.insert(tk.END, f"FileTrail Processing Results:\n")
            self.results_text.insert(tk.END, f"Total FileTrail records: {total_filetrail}\n")
            self.results_text.insert(tk.END, f"Records with PT_US_HOU_WCK: {filtered_count}\n\n")
            
            # Load comparison files
            comparison_data = {}
            comparison_columns = {
                'exploration_archives': 'EA Line Name',
                'open_works': 'LINE',
                'lines_3d': 'SURVEY'
            }
            
            progress_step = 20
            for file_type, column_name in comparison_columns.items():
                self.status_var.set(f"Loading {file_type.replace('_', ' ')}...")
                self.progress_var.set(20 + progress_step)
                progress_step += 15
                
                if self.file_paths[file_type]:
                    data = self.load_data(self.file_paths[file_type])
                    if data is not None and column_name in data.columns:
                        comparison_data[file_type] = data[column_name].dropna().tolist()
                        self.results_text.insert(tk.END, f"{file_type.replace('_', ' ').title()}: {len(comparison_data[file_type])} records\n")
                    else:
                        self.results_text.insert(tk.END, f"{file_type.replace('_', ' ').title()}: Column '{column_name}' not found or file error\n")
                else:
                    self.results_text.insert(tk.END, f"{file_type.replace('_', ' ').title()}: Not provided\n")
            
            self.results_text.insert(tk.END, "\n")
            
            # Process matches
            self.status_var.set("Processing matches...")
            self.progress_var.set(80)
            
            # Add match columns to filtered data
            filtered_filetrail['EA_Match'] = ""
            filtered_filetrail['EA_Match_Type'] = ""
            filtered_filetrail['OW_Match'] = ""
            filtered_filetrail['OW_Match_Type'] = ""
            filtered_filetrail['3D_Match'] = ""
            filtered_filetrail['3D_Match_Type'] = ""
            filtered_filetrail['Has_Any_Match'] = False
            
            # Track statistics
            stats = {
                'exploration_archives': {'exact': 0, 'substring': 0, 'fuzzy': 0, 'total': 0},
                'open_works': {'exact': 0, 'substring': 0, 'fuzzy': 0, 'total': 0},
                'lines_3d': {'exact': 0, 'substring': 0, 'fuzzy': 0, 'total': 0}
            }
            
            match_details = []
            
            for idx, row in filtered_filetrail.iterrows():
                line_id = row['LINE_ID']
                has_match = False
                
                # Check each comparison database
                for file_type, data_list in comparison_data.items():
                    matches = self.find_matches(line_id, data_list)
                    
                    if matches:
                        has_match = True
                        best_match = matches[0]
                        stats[file_type][best_match['match_type']] += 1
                        stats[file_type]['total'] += 1
                        
                        # Store match info
                        if file_type == 'exploration_archives':
                            filtered_filetrail.loc[idx, 'EA_Match'] = best_match['value']
                            filtered_filetrail.loc[idx, 'EA_Match_Type'] = best_match['match_type']
                        elif file_type == 'open_works':
                            filtered_filetrail.loc[idx, 'OW_Match'] = best_match['value']
                            filtered_filetrail.loc[idx, 'OW_Match_Type'] = best_match['match_type']
                        elif file_type == 'lines_3d':
                            filtered_filetrail.loc[idx, '3D_Match'] = best_match['value']
                            filtered_filetrail.loc[idx, '3D_Match_Type'] = best_match['match_type']
                        
                        # Store detailed match info
                        match_details.append({
                            'FileTrail_LINE_ID': line_id,
                            'Database': file_type.replace('_', ' ').title(),
                            'Matched_Value': best_match['value'],
                            'Match_Type': best_match['match_type'],
                            'Score': best_match['score']
                        })
                
                filtered_filetrail.loc[idx, 'Has_Any_Match'] = has_match
            
            # Store results
            self.results['filtered_filetrail'] = filtered_filetrail
            self.results['match_details'] = pd.DataFrame(match_details)
            self.results['unique_records'] = filtered_filetrail[~filtered_filetrail['Has_Any_Match']].copy()
            
            # Display statistics
            self.results_text.insert(tk.END, "Match Statistics:\n")
            for file_type, stat in stats.items():
                if stat['total'] > 0:
                    self.results_text.insert(tk.END, f"{file_type.replace('_', ' ').title()}: {stat['total']} matches\n")
                    self.results_text.insert(tk.END, f"  - Exact: {stat['exact']}\n")
                    self.results_text.insert(tk.END, f"  - Substring: {stat['substring']}\n")
                    self.results_text.insert(tk.END, f"  - Fuzzy: {stat['fuzzy']}\n")
            
            unique_count = len(self.results['unique_records'])
            self.results_text.insert(tk.END, f"\nUnique FileTrail records (no matches): {unique_count}\n")
            
            # Complete
            self.status_var.set("Processing complete!")
            self.progress_var.set(100)
            self.export_button.config(state=tk.NORMAL)
            
        except Exception as e:
            messagebox.showerror("Error", f"Processing failed: {str(e)}")
            self.status_var.set("Error occurred")
        
        finally:
            self.process_button.config(state=tk.NORMAL)
    
    def export_to_excel(self):
        """Export results to Excel file"""
        if not self.results:
            messagebox.showwarning("Warning", "No results to export!")
            return
        
        # Get output file path
        output_path = filedialog.asksaveasfilename(
            title="Save Results",
            defaultextension=".xlsx",
            filetypes=[("Excel files", "*.xlsx")]
        )
        
        if not output_path:
            return
        
        try:
            with pd.ExcelWriter(output_path, engine='openpyxl') as writer:
                # Sheet 1: Unique FileTrail records
                self.results['unique_records'].to_excel(
                    writer, sheet_name='Unique_FileTrail_Records', index=False
                )
                
                # Sheet 2: All FileTrail records with match info
                self.results['filtered_filetrail'].to_excel(
                    writer, sheet_name='All_FileTrail_Records', index=False
                )
                
                # Sheet 3: Match details
                if not self.results['match_details'].empty:
                    self.results['match_details'].to_excel(
                        writer, sheet_name='Match_Details', index=False
                    )
            
            messagebox.showinfo("Success", f"Results exported to {output_path}")
            
        except Exception as e:
            messagebox.showerror("Error", f"Export failed: {str(e)}")


def main():
    root = tk.Tk()
    app = FileTrailComparator(root)
    root.mainloop()


if __name__ == "__main__":
    main()
